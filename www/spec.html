<html lang="en" >
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="/js/reconnecting-websocket.min.js"></script>
	<script src="/js/chroma.min.js"></script>
	<title>Xethru Spectrogram</title>

</head>
<body ng-app="xethru" >
<!-- <div> -->
	  <canvas id="Spectrogram"></canvas>
<!-- </div> -->

<script>

	var canvas = document.getElementById('Spectrogram');
	var ctx = canvas.getContext('2d');

	// var tempCanvas = document.createElement("canvas"),
	// tempCtx = tempCanvas.getContext("2d");

	var NormaliseArray = [];

	function Normalise() {
		var offset = 0.4
		var framesize = 0.04
		for (var i =0 ; i<52; i++){
			NormaliseArray[i]= (offset^4) + 4*framesize*i*(offset^3) - 6*(offset^2)*(framesize^2) - 4*i*offset*(framesize^3) + (framesize^4);
			// console.log(i, NormaliseArray[i])
		}
	}
	Normalise()
	var normalised =[]

	var AmpClutterMap = [];
	for (var i =0 ; i<52; i++){
		AmpClutterMap[i]= 0
	}

	function AmpUpdateClutterMap(amplitude, weight) {
		for (var i =0 ; i<52; i++){
			AmpClutterMap[i]= AmpClutterMap[i]*(1-weight) + (amplitude[i]*weight)
		}
	}

	var PhaseClutterMap = [];
	for (var i =0 ; i<52; i++){
		PhaseClutterMap[i]= 0
	}

	function PhaseUpdateClutterMap(amplitude, weight) {
		for (var i =0 ; i<52; i++){
			PhaseClutterMap[i]= PhaseClutterMap[i]*(1-weight) + (amplitude[i]*weight)
		}
	}

	var lastPhase = [];
	var currentPhase =[];
	var phaseAngleLast = [];
	var phaseArclength = [];
	var phaseArclengthlast = [];
	var phaseArclengthCurrent = [];

	for (var i =0 ; i<52; i++){
		lastPhase[i]= 0
		currentPhase[i] =0 ;
		phaseAngleLast[i] =0 ;
		phaseArclengthlast[i] =0 ;
		phaseArclengthCurrent[i] =0 ;
	}

	function UpdatePhasearcLength(arclength, weight) {
		for (var i =0 ; i<52; i++){
			// k.le + k.g*(m-k.le)
			phaseArclengthlast[i] = phaseArclengthCurrent[i]
			phaseArclengthCurrent[i]= phaseArclengthlast[i] + weight*(arclength[i] - phaseArclengthlast[i])
		}
	}


	function arcLength(now, last) {
		// now = (now + last)/2
		var delta = last-now
		if (delta > Math.PI) {
			delta-=(Math.PI*2)
		}
		if (delta < -Math.PI) {
			delta+=(Math.PI*2)
		}
		var length = (delta/(Math.PI*2))
		// console.log(length)
		return length
	}



	amplitudeGradient = chroma.scale(['white','darkred', 'teal','indigo', 'pink','green', 'orange','blue', 'yellow','black', 'lightgreen']);
	phaseGradient = chroma.scale(['lightyellow', 'orange', 'darkred']);

  	var bbloc = window.location,
  	    bbwebsocket_uri;
  	if (bbloc.protocol === "https:") {
  	    bbwebsocket_uri = "wss:";
  	} else {
  	    bbwebsocket_uri = "ws:";
  	}
  	bbwebsocket_uri += "//" + bbloc.host + "/ws/bb";
    var bbconn = new ReconnectingWebSocket(bbwebsocket_uri);

  	bbconn.onclose = function(e) {};

    bbconn.onopen = function(e) {
		console.log("Connected")
	};
    var WebsocketMessageCount = 0

    bbconn.onmessage = function(e) {
      var data = JSON.parse(e.data);
	//   console.log(arcLength(data.phase, phaseAngleLast))

	  for (var i = 0; i < data.phase.length; i++) {
		phaseArclength[i] =arcLength(data.phase[i], phaseAngleLast[i])
	  }
	  phaseAngleLast = data.phase

	  for (var i = 0; i < data.amplitude.length; i++) {
		  normalised[i] = (NormaliseArray[i] * data.amplitude[i])/200
	  }
	  AmpUpdateClutterMap(normalised, 0.05)
	  for (var i = 0; i < data.bins; i++) {
		  normalised[i]= normalised[i]-AmpClutterMap[i]
		//   data.phase[i] = (Math.sin(data.phase[i]))
	  }

	//   PhaseUpdateClutterMap(data.phase, 0.10)
	//   for (var i = 0; i < data.bins; i++) {
	// 	  data.phase[i]= data.phase[i]-PhaseClutterMap[i]
	// 	//   data.phase[i]= Math.abs(data.phase[i])
	//   }
	  //
	//   UpdatePhase(phaseArclength, 0.5)
	//   console.log(currentPhase)
	// UpdatePhasearcLength(phaseArclength, 0.5)
	  drawSpectrogram(normalised, phaseArclength)
    };

	var shown = false;
	var count = 0;


	ctx.canvas.width  = (window.innerWidth-50);
	ctx.canvas.height  = window.innerHeight/2;
	var max
	var min
	function drawSpectrogram(data, phase) {
		var feed = 3
		var hsize = 2
		source = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
		ctx.putImageData(source, 0, feed)
		ctx.clearRect(0, 0, ctx.canvas.width, 100);
		bars = data.length;
		for (var i = 0; i < bars; i++) {
			data[i]= Math.abs(data[i])
			bar_startx = i * canvas.width/bars/hsize;
			bar_width = (ctx.canvas.width/bars/hsize);
			bar_height = (-(data[i])*ctx.canvas.height/10)-feed;
			ctx.fillStyle = amplitudeGradient(data[i])
			ctx.fillRect(bar_startx, 100, bar_width, bar_height);
		}
		for (var i = 0; i < bars; i++) {
			bar_startx = (i+52) * canvas.width/bars/hsize;
			bar_width = (ctx.canvas.width/bars/hsize);

			bar_height = (-phase[i]*ctx.canvas.height/10)-feed;
			if (bar_height > -feed) {
				bar_height = -feed
			}
			var colourfill = (phase[i]*data[i]*500)+.5
			ctx.fillStyle = phaseGradient(colourfill)
			ctx.fillRect(bar_startx, 100, bar_width, bar_height);
		}
	}






</script>

</body>
